\documentclass[12pt,article]{article}
\usepackage{fullpage}
\usepackage[top=2cm, bottom=4.5cm, left=2cm, right=2cm]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb,amscd}
\usepackage{lastpage}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{mathrsfs}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{mdframed}
\usepackage{changepage}   % for the adjustwidth environment
\usepackage{forest} 
\usepackage{tikz}   % For graph

\usepackage{float}  % To inforce inserting images at the right place

\usepackage{algorithm}
\usepackage{algpseudocode}

% For recursive formulation, adapted from https://tex.stackexchange.com/questions/580333/typing-sequences-recursively-in-overleaf
\usepackage{mathtools}
\makeatletter
\newcases{centercases}{\quad}
  {\hfil$\m@th\displaystyle{##}$\hfil}
  {$\m@th\displaystyle{##}$\hfil}{\lbrace}{.}
\makeatother

\newcommand{\Tau}{\mathrm{T}}


% For matrix
\def\horzbar{\text{magic}}

\hypersetup{%
  colorlinks=true,
  linkcolor=blue,
  linkbordercolor={0 0 1}
}

\setlength{\parindent}{0.0in}
\setlength{\parskip}{0.05in}

\newcommand\projnumber{3}
\newcommand\course{CS534}
\newcommand\OSUID{934370552}
\newcommand\Email{buivy@oregonstate.edu}
\newcommand\Name{Vy Bui}
\newcommand\tab[1][1cm]{\hspace*{#1}}

\pagestyle{fancyplain}
\headheight 35pt
\lhead{Practice Assignment \projnumber}
\rhead{Feb. 20, 2023}
\lfoot{}
\cfoot{}
\rfoot{\small\thepage}
\headsep 1.5em

\newenvironment{problem}[2][Problem]
    { \begin{mdframed}[backgroundcolor=gray!20] \textbf{#1 #2} \\}
    {  \end{mdframed}}
   

% Make Rightarrow with superscript
% \makeatletter
% \newcommand{\xRightarrow}[2][]{\ext@arrow 0359\Rightarrowfill@{#1}{#2}}
% \makeatother

\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{4cm}

        \textbf{\Large CS515 - Algorithms \& Data Structures}

        \vspace{0.5cm}
 
        \textbf{\Large Practice Assignment \projnumber}
 
        \vspace{1cm}

        Vy Bui - 934370552

        \vspace{2cm}

        Instructor: Professor Glencora Borradaile
        \vfill
             
        \vspace{0.8cm}
      
             
        The School of Electrical Engineering and Computer Science\\
        Oregon State University\\
             
    \end{center}
\end{titlepage}

%==============================================================================%
\begin{problem}{1} 
Job Scheduling
\end{problem}

\textbf{(a)}
Let $T = \{t_1, t_2, ..., t_n\}$ be the time the jobs $j_1, j_2, ..., j_n$ take.

\begin{algorithm}
\caption{$A(T)$}\label{alg:q2}
\begin{algorithmic}
    \State $sortedT \gets sort(T)$
    \State $lastJobCompleteTime \gets 0$
    \State $totalTime \gets 0$
    \For{t in T}
        \State $totalTime \gets totalTime + lastJobCompleteTime + t$
        \State $lastJobCompleteTime \gets lastJobCompleteTime + t$
    \EndFor

    \Return $sortT, totalTime$
\end{algorithmic}
\end{algorithm}

\textbf{(b)}
We have 
$$\sum_{i=1}^{n} C_i = t_1 + (t_1 + t_2) + (t_1 + t_2 + t_3) + ... + t_n 
= nt_1 + (n-1)t_2 + ... + (n+1-i)t_i + (n-i)t_{i+1} + ... + t_n$$

Theorem 1: The total cost is minimum when $t_i \leq t_{i+1}$ for all i \\
Proof: assume that there exists some optimal job ordering that has $t_i > t_{i+1}$. Observe that there are (n + 1 - i) of $t_i$ terms and (n - i) of $t_{i+1}$ terms in the above summation. If we swap $t_i$ and $t_{i+1}$, the summation will have one more $t_{i+1}$ term and one less $t_i$ term. Because $t_i > t_{i+1}$, the total cost after the swap will reduce, thus producing a not worse solution. From some optimal solution O, we can swap these inversions ($t_{i} > t_{i+1}$) until there is no inversions left in the ordering, which is exactly the solution of our greedy algorithm. And each swap guarantees to produce at least equally good result.

\textbf{(c)} \\
The algorithm takes $O(nlogn)$ to sort the list of jobs by time needed to complete the job. It then takes $O(n)$ time to iterate through the sorted list and accumulate the total time. The ordering is the order of the sorted list. In total, it takes $O(nlogn)$ time.

%==============================================================================%
\newpage
\begin{problem}{2} 
A wrong greedy algorithm for the Knapsack problem 
\end{problem}

\textbf{(a)}

\textbf{(b)}

\textbf{(c)}

%==============================================================================%
\newpage
\begin{problem}{3} 
A randomized algorithm for generating biased random bits
\end{problem}
- mutually independent
- p(F) = p(T) = 0.5



\textbf{(a)}

\textbf{(b)}

\textbf{(c)}

%==============================================================================%
\newpage
\begin{problem}{4} 
Tax Screening System
\end{problem}

\bibliographystyle{alpha}
\bibliography{mybib}
\end{document}
